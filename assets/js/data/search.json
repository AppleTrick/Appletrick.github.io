[ { "title": "redux immutable 문제 해결하기 (createAction, createReducer)", "url": "/posts/reduxCreateActionCreateReducer%EB%AC%B8%EC%A0%9C/", "categories": "TS, React, Redux", "tags": "개념, Redux, TypeScript, React", "date": "2022-08-01 00:00:00 +0900", "snippet": "redux immutable 문제 해결하기redux 사용하다 보니 문제가 생겼다.const initialState: ScheduleData = { Expedition: { Weekly: { ChallengeAbyss: { IsDone: false, Visible: true, }, EffonaReward: { IsDone: false, Visible: true, }, CrackPieceReward: { IsDone: false, Visible: true, }, ChallengeGuardian: { IsDone: false, Visible: true, }, }, }, Characters: [ { CharacterInform: { CharacterName: &quot;하얀눈송이아래&quot;, Job: &quot;건슬링어&quot;, Level: 1591, }, Daily: { ChaosDungeon: { isDone: false, RestGage: 0, Visible: true, }, Gaurdian: { isDone: false, RestGage: 0, Visible: true, }, DailyEffona: { isDone: false, Visible: true, }, GuildCheck: { isDone: false, Visible: true, }, }, Weekly: { Argos: { isDone: false, Visible: true, }, Valtan: { IsDone: false, GateNumber: 0, Visible: true, }, Viakiss: { IsDone: false, GateNumber: 0, Visible: true, }, Kukusaiton: { IsDone: false, GateNumber: 0, Visible: true, }, Abrelshood: { IsDone: false, GateNumber: 0, Visible: true, }, Kayangal: { IsDone: false, GateNumber: 0, Visible: true, }, }, }, ],};이렇게 큰값의 데이터를 어떻게 변화 시킬것인가에 대해 문제가 생겼다.react에서 redux를 사용할 때 상태는 불변성을 유지시켜줘야된다.즉 값을 유지 시켜줘야되는데 문제는 이렇게 큰 값의 경우 코드의 양이 많아지고 데이터를 변경하기 까다로워져 버린다.문제 해결의 방안 immer.js ReduxToolkit 사용 (createAction, createReducer )처음 해결방안으로는 immer을 이용하여서 문제를 해결하려고 했으나 Redux Toolkit을 통해 immer와 같은 불변성 문제를 해결방법이 있는걸 보고 ReduxToolkit을 이용하여 문제 방안 해결새로운 문제 : createAction과 createReducer는 TypeScript에서 어떻게 사용하나?핵심은 createReducer 이지만 action을 좀 더 편하게 사용하기 위해 createAction 사용하는법createAction 사용하기구 액션정의// 액션 이름을 타입화const actionNameType = &quot;actionName&quot; as const;// 액션 생성const action = (value) =&amp;gt; ({ type: actionNameType, payload: { value },});액션을 정의를 이렇게 했다면createAction으로 actiont 생성// 액션 이름을 타입화const actionNameType = &quot;actionName&quot; as const// 1 - 1 전달 값이 없을 경우 액션 생성const action = createAction(actionNameType);---------------------------------------------------------------------// 1 - 2 payload와 같이 전달할 값이 있을 경우// payload의 타입 정의type Profile = { name : string adress : string}// Generic을 이용하여 타입 전달const action = createAction&amp;lt;Profile, typeof actionNameType&amp;gt;(actionNameType);핵심은 payload 타입 정의하고 Generic 에 넣어주는것createReducerconst createReducerName = createReducer(initialState, { actionName: (state, action) =&amp;gt; state + action.payload,});reducer를 만들때와 큰 차이는 없다. initialState에는 생성값이 되고 이후의 Map(K,V)의 Key값에 createAction에 정의했던 actionName을 쓰고 Value 값에는 함수로 (state , action) ⇒ 형태로 state 값에는 initialState 가 들어가고 action에는 정의한 action이 들어와 action.payload를 사용하면 인자로 받아온 값을 사용 가능하다.후기사실 정확한 해결책인지는 모르겠지만, 일단 기록하고 보자.." }, { "title": "as Const?", "url": "/posts/asConst/", "categories": "TS", "tags": "개념, TypeScript", "date": "2022-07-14 00:00:00 +0900", "snippet": "궁금증의 동기!타입스크립트 사용해서 프로젝트 하던중 아래와 같은 예제 코드를 발견 했다.const INCREASE = &quot;counter/INCREASE&quot; as const;as const 가 어떤 역할을 하는지 좀 처럼 감을 못잡았다. 바로 구글링let 변수에서let hihi = &quot;abc&quot;;hihi = &quot;bbbb&quot;;// hihi 는 string 타입임으로 정상적으로 변환이 된다let hello = &quot;world&quot; as const;hello = &quot;hihi&quot;;// hello 의 타입은 &#39;world; 임으로 변환 못함as const 의 역할은 그 자체를 하나의 타입으로 바꿔준다는 것을 알수 있다.객체에서const thisObj = { hello: &quot;world&quot; as const, foo: &quot;bar&quot;,};// 객체의 타입중 hello 는 &#39;world&#39; 타입으로 변환const thisObj1 = { hisName: &quot;park&quot;, hisAge: 18,} as const;// 객체 전체가 타입이 되고 readonly 로 변환as const 의 결과 해당 값을 전부 하나의 타입으로 지정해준다. object 속성을 전부 readonly 시켜준다." }, { "title": "JS에서의 기초 Redux 사용 방법과 구조", "url": "/posts/Redux%EA%B8%B0%EC%B4%88%EC%82%AC%EC%9A%A9%EB%B2%95/", "categories": "Redux", "tags": "개념, 공부, Redux", "date": "2022-06-18 01:00:00 +0900", "snippet": "기초부터 JS에서의 리덕스를 알아보자 첫째로 리덕스의 문법이 바뀐건 아니지만 vscode에서도 바꾸길 권장하기에 redux_toolkit을 이용해서 바꾸려고 한다.리덕스는 아래와 같은 함수의 구조로 이루어 진다.import { configureStore } from &quot;@reduxjs/toolkit&quot;;const store = configureStore({ reducer: -function- });function 에는 reducer에는 함수를 인자로 넣어 어떤 동작에 대해 어떻게 행동하는지에 대한 정의를 내려주는 함수를 정의 해준다.const reducer = (-initialState-, -action-) =&amp;gt; { switch (action.type) { case a : return; case b : return; default: return state; }};reducer 함수에서는 인자로 보내진 action.type이 어떤것인지에 따라 케이스별로 값의 변화를 리턴함주의사항으로 return 을 할때 새로운 값으로 return 으로 값 변화한 값이 아닌 새로운 값으로 리턴해야됨arr.push(1) ❌[ 1 , …arr] ⭕️redux값을 정해준 store에서 정해진 다양한 함수가 있다getState()현재 설정된 store에서 저장된 값을 가지고 온다.// reducer 함수에서 처음에 설정된 initalState 값이 1 이면 1을 리턴해줌store.getState();dispatch(actionObject)store 에 있는 값을 변화 시킬때 사용한다.store.dispatch({type : “add’ , text : “추가하기” }) 코드는 reducer 에서 해당 action.type 이 add 인것을 확인하고 해당된 코드를 실행해 값에 변화를 준다.store.dispatch({type: ?? , ?value})subscribe(function)subscribe 는 redux의 store의 값이 변화할때 실행되는 함수를 정해줌const onChange = () =&amp;gt; { number.innerText = countStore.getState();};store.subscribe(onChange);" }, { "title": "2022.06.18 근황 정리", "url": "/posts/%EA%B7%BC%ED%99%A9%EC%A0%95%EB%A6%AC/", "categories": "일기", "tags": "일기", "date": "2022-06-18 00:00:00 +0900", "snippet": "블로그 안 쓰는 동안 했던일 redux 공부 react typescript 공부 로아플 프로젝트 준비 취업준비.앞으로 해야될일 취업 redux 공부 내용 정리 로아플 프로젝트 완성하기" }, { "title": "interface에관하여", "url": "/posts/interface%EC%97%90%EA%B4%80%ED%95%98%EC%97%AC/", "categories": "TS", "tags": "TS, TypeScript, 타입스크립트, interface, 개념", "date": "2022-06-03 00:00:00 +0900", "snippet": "interface는 type과 유사하다. 똑같이 해당 구조를 사전에 설정해 주는 역할을 한다.interface와 typetype에서의 코드type NickName1 = string;type HealthBar1 = number;type Hamberg = Array&amp;lt;string&amp;gt;;type Team = &quot;red&quot; | &quot;blue&quot; | &quot;yellow&quot;; // 1️⃣ 타입에서 특정 값만을 가지게 할 수 있음type Player3 = { nickname: NickName1; healthBar: HealthBar1; team: Team;};const LeeP: Player3 = { nickname: &quot;LeeP&quot;, healthBar: 12, team: &quot;red&quot;, // 1️⃣ red , blue, yellow 3가지중 하나만 가능};type Coffee = string;const ediya: Coffee = &quot;이디야&quot;;타입으로 값을 제한 할 수 있다. 위의 코드에서는 type에서 Team 은 red, blue, yellow 중 하나만 가능하다.이처럼 타입은 코드에서 type은 다재다능한 키워드이다.object를 정의 할 수 있고 특정 타입을 제한 할 수 있다.또한 alias 기능을 사용하여 디테일하게 사용이 가능하다. 타입은 모든 것이 될 수 있다!interface는 ?interface는 type과는 다르게 object 모양을 알려주는데만 사용한다. 코드를 보면 다음과 같다.type NickName1 = string;type HealthBar1 = number;type Hamberg = Array&amp;lt;string&amp;gt;;type Team = &quot;red&quot; | &quot;blue&quot; | &quot;yellow&quot;; // 타입에서 특정 값만을 가지게 할 수 있음interface Player3 { nickname: NickName1; healthBar: HealthBar1; team: Team;}interface는 object를 정의하는 이유 하나로 사용한다.type 과 interface에서 다른점들type과 interface에서는 다른점들이 여러가지가 있다.상속type과 interface에서는 상속에서 차이가 난다.interface에서의 상속 코드interface User { name: string;}interface Player extends User {}const park: Player = { name: &quot;park;&quot;,};인터페이스의 경우 상속은 extends 키워드를 통해 하는 반면type에서의 상속 코드type User = { name: string;};type Player = User &amp;amp; {};const park: Player = { name: &quot;park;&quot;,};type 에서는 쿠체적인 적용 없이 &amp;amp; 연산자를 통해 상속해준다.interface는 property의 축적이 가능하다.property의 축적이 가능하다는 말은 코드를 보면 이해하기 쉽다.interface User { name: string;}interface User { address: string;}interface User { addressNum: number;}const park: User = { name: &quot;park&quot;, address: &quot;seoul&quot;, addressNum: 125,};User interface를 만들고 여러개를 중첩해서 만들어도 typescript에서 하나로 합쳐준다." }, { "title": "타입스크립트 class", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8Class/", "categories": "TS", "tags": "TS, TypeScript, 개념, 타입스크립트, 클래스, 추상클래스", "date": "2022-06-01 00:00:00 +0900", "snippet": "typescript도 javascript와 마찬가지로 class를 사용가능하다. 그렇지만 typescript는 자바스크립트와 class 에서는 크게 다른점이 있다접근 제한자의 사용가능 public private protected접근제한자의 사용이 가능하다는 점이다.Typescript의 경우class Player { constructor( private firstname: string, private secondname: string, public nickname: string ) {}}const park = new Player(&quot;park&quot;, &quot;changhee&quot;, &quot;appletrick&quot;);JS에서 처럼 불편하게 this.? = ? 를 사용할 필요가 없어진다.위의 코드를 JS에서는 다음과 같아진다.Javascript의 경우class Player { constructor(firstname, secondname, nickname) { this.firstname = firstname; this.secondname = secondname; this.nickname = nickname; }}const park = new Player(&quot;park&quot;, &quot;changhee&quot;, &quot;appletrick&quot;);확실히 가독성면에서 TS가 훨씬 앞선다.추상 클래스, 추상 메서드의 사용 가능TS에서는 추상 클래스와 추상 메서드의 사용이 가능하다.자세한 내용을 코드를 보면서 이해하자Typescriptabstract class User { // 1️⃣ 추상클래스 선언 constructor( private firstname: string, private secondname: string, protected nickname: string // 3️⃣ protected 접근제한자를 이용하여 자식요소에서도 사용 ) {} abstract getNickName(): void; // 2️⃣ 추상메서드의 선언 User 클래스를 상속받을경우 반드시 해당 메소드를 재선언해줘야됨 getFullName() { // 4️⃣ method 에서도 접근제한자 사용 가능 return `${this.firstname} ${this.secondname}`; }}class Player extends User { // 1️⃣ 추상클래스를 상속 받음 getNickName() { // 2️⃣ 추상메서드 완성 console.log(this.nickname); // 3️⃣ protected 로 인해 해당 value에 접근 가능 }}const park = new Player(&quot;park&quot;, &quot;changhee&quot;, &quot;appletrick&quot;);1️⃣ User 추상 클래스를 선언해주고 Player 클래스에서 User 클래스를 상속 받았다.2️⃣ User 추상클래스에서 getNickName 이라는 추상 메서드를 선언해주었다. 때문에 Player 클래스에서도 추상메서드 getNickName에 대한 내용을 다시 작성해줘야된다.3️⃣ Player 클래스에서 nickname에 대한 값을 사용하려면 상속받는 클래스에서 값을 사용해야된다. 때문에 접근제한자를 protected 로 변경하여 상속받는 값에서도 this를 사용할 수 있게 만들어준다.4️⃣ 추상 클래스에서 메소드에서도 접근제한자 지정이 가능하다Javascript의 경우class User { constructor(firstname, secondname, nickname) { this.firstname = firstname; this.secondname = secondname; this.nickname = nickname; } getFullName() { return `${this.firstname} ${this.secondname}`; }}class Player extends User { getNickName() { console.log(this.nickname); }}const park = new Player(&quot;park&quot;, &quot;changhee&quot;, &quot;appletrick&quot;);Javascript도 동일하게 사용할 수 있지만 접근제한자 부분이 없으므로 강력하게 오류나 틀린부분을 찾기 어려워진다.결론TS로 클래스 문법을 사용하면 엄격하고 규격있게 사용된다. 때문에 잘못된 부분이 있으면 빠르게 오류를 표기해주므로 쉽게 인지할 수 있다. JS에서도 쉽게 사용가능하지만 그만큼 부족한 부분도 생긴다." }, { "title": "타입스크립트의 제너릭", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%EC%A0%9C%EB%84%88%EB%A6%AD/", "categories": "TS", "tags": "TS, TypeScript, 개념, Generic, 제너릭", "date": "2022-05-31 00:00:00 +0900", "snippet": "제너릭을 안 쓸때의 문제점타입스크립트의 제너릭은 무엇일까? 일단 제너릭을 알기전에 제너릭을 안쓸때의 문제점을 보자type SuperPrint = { // 함수의 타입을 일일이 정의를 해줘야된다. (arr: number[]): void; (arr: boolean[]): void; (arr: string[]): void; (arr: (number | boolean)[]): void;};const superPrint: SuperPrint = (arr) =&amp;gt; { arr.forEach((i) =&amp;gt; console.log(i));};superPrint([1, 2, 3, 4]);superPrint([true, false, true]);superPrint([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);superPrint([1, 2, true, false]);배열의 내용을 하나씩 다 출력하는 함수를 만든다고 했을때 type에 알지 못하는 타입의 배열의 타입이 들어갈 경우 타입에 일일이 하나씩 정의를 해야되는 문제가 발생한다.제너릭으로의 해결코드를 제너릭을 사용하면 다음과 같이 간단하게 정리가 된다.type SuperPrint = { // 제너릭을 통해 타입을 간단히 정리하였다. &amp;lt;T&amp;gt;(arr: T[]): void;};const superPrint: SuperPrint = (arr) =&amp;gt; { arr.forEach((i) =&amp;gt; console.log(i));};superPrint([1, 2, 3, 4]);superPrint([true, false, true]);superPrint([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);superPrint([1, 2, true, false]);&amp;lt;T&amp;gt; 에서 call signature를 맞춰줌으로써 타입에 대한 값이 생긴다.다수의 제너릭을 사용하는 방법제너릭은 인자 들어가는 부분부터 타입이 인지가 되기에 두개를 쓸때는 아래와 같이 사용한다.type SuperPrint = { &amp;lt;T, M&amp;gt;(arr: T[], value: M): void;};const superPrint: SuperPrint = (arr, val) =&amp;gt; { arr.forEach((i) =&amp;gt; console.log(i));};superPrint([1, 2, 3, 4], &quot;x&quot;);superPrint([true, false, true], 1);superPrint([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], true);superPrint([1, 2, true, false], []);function 으로 Generics 정의하기function superPrint1&amp;lt;T&amp;gt;(a: T[]) { return a[0];}superPrint1([1, 2, 3, 4]);// superPrint1&amp;lt;boolean&amp;gt;([1, 2, 3, 4]); // error!// 제너릭으로 타입을 직접 정의할 수 있지만 TypeScript가 자연스럽게 처리 되도록 하는게 좋다.superPrint1([true, false, true]);superPrint1([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);superPrint1([1, 2, true, false]);함수에서 superPrint1&amp;lt;boolean&amp;gt;([1, 2, 3, 4]) 와 같이 제너릭을 직접적으로 선언할 수 도 있지만, 자연스럽게 타입스크립트에서 처리되도록 할 수 있는게 좋다.type에서 Generics 사용하기type Player&amp;lt;E&amp;gt; = { name: string; extraInfo: E;};type Extra = { HP: number;};type ParkPlayer = Player&amp;lt;Extra&amp;gt;;const Park: ParkPlayer = { name: &quot;park&quot;, extraInfo: { HP: 1000, },};const Lee: Player&amp;lt;null&amp;gt; = { name: &quot;Lee&quot;, extraInfo: null,};타입 안에 타입형식으로 다음과 같이도 사용할 수 있다." }, { "title": "타입스크립트에서의 overloading", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9COverloading/", "categories": "TS", "tags": "TS, TypeScript, 개념", "date": "2022-05-30 00:00:00 +0900", "snippet": "parameter 개수가 같고 타입이 다를경우// parameter 개수가 같고 타입이 다를 경우type Config = { path: string; state: object;};type Push = { (path: string): void; (config: Config): void;};const push: Push = (config) =&amp;gt; { // 조건이 다를 경우를 처리해줘야됨 if (typeof config === &quot;string&quot;) { console.log(config); } else { console.log(config.path); }};처리 부분에서 if ~ else 문을 통해 해당 타입이 어떤 형태별로 분류된 함수를 실행 시켜준다.parameter 개수가 다를 경우// parameter 개수가 다를 경우type Add = { (a: number, b: number): number; (a: number, b: number, c: number): number;};const add: Add = (a, b, c?: number) =&amp;gt; { // ?: 옵셔널을 통해 c가 있을 경우만 처리 if (c) { return a + b + c; } return a + b;};파라미터가 여러개일 경우 ?: 를 통해 해당 파라미터의 존재여부를 없거나 존재하거나로 구분하여 함수를 실행 시켜준다." }, { "title": "잘 모르는 TS 타입", "url": "/posts/%EC%9E%98%EB%AA%A8%EB%A5%B4%EB%8A%94%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/", "categories": "TS", "tags": "TS, TypeScript, 개념", "date": "2022-05-30 00:00:00 +0900", "snippet": "unknown외부로부터 데이터가 오거나, 받아오는 타입의 종류를 모를경우 unknown으로 처리할 수 있음// unknownlet unknwonType: unknown;if (typeof unknwonType === &quot;string&quot;) { let b = a.toUpperCase();}if (typeof unknwonType === &quot;number&quot;) { let b = a + 1;}void함수에서 값 return이 없는 경우 함수의 타입은 void로 default 로 된다.// voidfunction hihi() { // : void .. // return type이 없음}never리턴하는 값이 존재하지 않을때 사용한다.error 의 경우function somethingE(): never { throw new Error();}error가 발생함으로 값의 리턴이 없다.다른 코드에서 타입으로 존재할 경우function hihihi(something: string | number) { if (typeof something === &quot;string&quot;) { something; // string } else if (typeof something === &quot;number&quot;) { something; // number } else { something; // never }}마지막 else 구문에서 something의 타입은 never 다. 즉 없어야 되는 존재이다." }, { "title": "타입스크립트의 없는 타입은 어떻게 하는가?", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%97%86%EB%8A%94%ED%83%80%EC%9E%85%EC%9D%80/", "categories": "TS", "tags": "Typescript, TS, 개념", "date": "2022-05-25 00:00:00 +0900", "snippet": "자바스크립트와 만찬가지로 타입스크립트에서도 Object를 사용하여 다양하게 값을 정의 할 수 있다.타입스크립트는 엄격한 언어이기에 다음과 같은 문제가 발생한다.const person = { name: &quot;park&quot;,};person.name = &quot;Kim&quot;;person.age = 10; // error! age는 person 오브젝트에 존재하지않아자바스크립트에서는 문제 없이 작동했지만 타입스크립트로 실행했을때는 Object person에서 값을 선언과 타입을 정해주지 않았기에 문제가 발생했다. 해당문제는 optional properties를 통해 해당 문제를 해결한다.선택적 프로퍼티(optional properties )const person1: { name: string; age?: number;} = { name: &quot;park&quot;,};person1.age = 10;object를 생성할때 : {} 를 통해 어떤 오브젝트 형태인지 명시적으로 선언을 해주고 존재할수 있고 없을 수도 있는 항목은 선택적 프로퍼티 ?: 를 통해 처리해준다.person1의 age는 number 타입으로 올수있는데 없을수도 있다 라는 의미이다.그런데 이런 코드 보기 어렵지 않은가? 만약에 person1 , person2 , person3 의 동일한 객체를 만들때도 이렇게 불편한 코드를 계속해서 작성하기에는 가독성도 떨어지고 재사용성도 떨어진다.이런 이유로 TypeScript에서는 type alias 와 interface 방법을 지원한다.type Aliastype Player = { name: string; age?: number;};const player1: Player = { name: &quot;park&quot;,};const player2: Player = { name: &quot;Lee&quot;, age: 22,};const player3: Player = { name: &quot;Kim&quot;, age: 23,};type을 미리 선언하여 오브젝트에 적용하면 코드도 간결해지고 가독성도 높아진다.함수에서 Type이용하기type Human = { name: string; age?: number;};function playerName(name: string): Human { return { name, };}const human1 = playerName(&quot;park&quot;);console.log(human1); // { name: &#39;park&#39; }human1.age = 10;console.log(human1); // { name: &#39;park&#39;, age: 10 }const human2 = (name: string): Human =&amp;gt; { return { name };};화살표함수에서 TS사용하기type functionType1 = (a: number, b: number) =&amp;gt; string;const sum2: functionType1 = (a, b) =&amp;gt; { return `값은 (${a + b})`;};" }, { "title": "타입스크립트의 선언", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%EC%84%A0%EC%96%B8/", "categories": "TS, JS, 개념", "tags": "TS, JS, 개념", "date": "2022-05-24 00:00:00 +0900", "snippet": "타입 스크립트의 선언 방식에는 자바스크립트와 다르게 두가지 방법이 있다. 타입추론 명시적선언타입 추론타입추론은 일반적인 javascript 와 차이가 없어보인다.let a = &quot;string&quot;; // typescript 처리에서 변수 a 가 String 형태를 추론해준다.a = &quot;realString&quot;; // a가 String 타입이기에 같은 타입으로 변하는 것이 가능!a = 1; // error !위의 코드를 살펴보면 첫번째줄에 변수 a가 선언되었을때 타입추론이 발생하여 변수 a 는 String 타입으로 정해진다.두번째 줄에서는 같은 타입의 값을 넣었기에 변경해주는 것이 가능하다.세번째 줄은 변수 a의 타입은 String 으로 되어 있기에 number타입의 값을 넣어주면 오류가 발생하게 된다.명시적 타입 선언명시적 타입 선언은 말 그대로 변수에 값을 직접적으로 타입을 선언시키는 것이다.let myType: number = 777;선언 방식은 변수명 옆에 : type 형태로 선언하고 값을 넣어주면 된다.typescript의 타입종류는 기본 javascript에서 조금 더 추가 되어있는데 아래와 같은 타입이 존재한다.Booleanlet bool: boolean = true;true / false 값Numberlet num: number = 123;숫자 값Stringlet Hello: string = &quot;hi&quot;;문자열 값Arraylet arr1: number[] = [1, 2];let arr2: Array&amp;lt;string&amp;gt; = [&quot;Hello&quot;, &quot;World&quot;];배열을 두가지 방법이 있는데 첫번째는 [] 앞에 어떤 타입인지 말해주는 것이다.두번째는 제네릭 배역 타입을 이용하여 선언하는 것Tupplelet tupple1: [string, number] = [&quot;seoul&quot;, 2022];고정된 값이다. 순서가 틀리면 안된다.Enumenum Color { Red, Green, Blue,}let c: Color = Color.Green;자료 열거형Anylet isAny: any = 10;isAny = &quot;string&quot;;isAny = true;let anyArr: any[] = [1, 2, &quot;10&quot;, true];any는 알지못하는 타입을 가지고 올 때 유용한 타입Referencehttps://typescript-kr.github.io/pages/basic-types.html" }, { "title": "자바스크립트의 문제점", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%EB%AC%B8%EC%A0%9C%EC%A0%90/", "categories": "JS, TS", "tags": "javascript, typescript, JS, TS", "date": "2022-05-23 00:00:00 +0900", "snippet": "자바스크립트의 문제점타입스크립를 제대로 공부하기 전에 타입스크립틑 왜 사용하며, 어떤점 때문에 자바스크립트에서 타입스크립트로 넘어가는지 알아보자.타입스크립트란?타입스크립트는 자바스크립트에 타입을 추가해주는 문법이다. 되게 심플하다. 타입만 추가함으로써 얻을 수 있는 장점은 다음과 같다. 타입이 존재하기에 안전성 향상 런타임에러의 감소 생산성의 증가자바스크립트의 문제점현재의 자바스크립트 유연하다고 볼 수 있지만, 유연한게 독이 되는 경우 도 있다.자바스크립트의 문제[1, 2, 3, 4] + false; // 1,2,3,4false다음의 결과는 어떻게 나올까?자바스크립트의 결과에서는 1,2,3,4false 가 결과로 나온다. 타 언어에서는 말도 안되는 결과가 도출되는 현상이 일어난다.자바스크립트의 문제function divide(a, b) { return a / b;}console.log(divide(2, 3)); // 0.66666666666console.log(divide(&quot;aaaa&quot;)); // NaN나눗셈이라는 함수를 만들어 매개변수 2, 3을 보냈을경우 의도한 대로 0.6666666 이라는 값이 나오지만 매개변수에 “aaaaaa” 라는 문자열을 보냈을 경우 NaN 이라는 결과가 온다.NaN 은 숫자가 아니라는 것이지 절대 에러의 영역이 아니다. 또한 함수에는 매개변수의 갯수가 2개를 보냈어야되지만 문자열 하나만 보내도 결과 가나오기에 이 또한 에러가 나와야되지만 정상적으로 NaN라는 값만 결과로 보내준다.자바스크립트의 문제const person = { name: &quot;park&quot; };console.log(person.hello());객체를 만들어서 객체에 존재하지 않는 함수를 실행시켰다. 결과는 에러로 나오지만, 생각을 해보면 이는 결과를 출력하지 않으면 문제가 되는지 안되는지 모르게되는 상황이 발생된것이다. 즉 person.hello() 를 입력하는 순간 타 언어에서는 hello라는 함수가 없음을 알려주지만 자바스크립트는 이를 실행해야만 알 수 있다." }, { "title": "gitblog 구글 서칭하게 만들기", "url": "/posts/blog%EC%97%90GoogleSearching/", "categories": "Blogging", "tags": "블로그, blog, Google Search, Google", "date": "2022-05-21 01:00:00 +0900", "snippet": "Google Search Console로 접속하기https://search.google.com/search-console/about 에 접속한다.gitblog가 존재할 경우 URL 접두어 부분에 gitblog 사이트 입력을 해준다.html 파일을 다운로드 후에 root의 동일한 위치에 파일을 위치해준다.sitemap.xml 생성하기---layout: null---&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;urlset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd&quot; xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/reduxCreateActionCreateReducer%EB%AC%B8%EC%A0%9C/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-08-01T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/asConst/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-07-14T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/Redux%EA%B8%B0%EC%B4%88%EC%82%AC%EC%9A%A9%EB%B2%95/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-06-18T01:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%EA%B7%BC%ED%99%A9%EC%A0%95%EB%A6%AC/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-06-18T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/interface%EC%97%90%EA%B4%80%ED%95%98%EC%97%AC/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-06-03T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8Class/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-06-01T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%EC%A0%9C%EB%84%88%EB%A6%AD/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-31T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9COverloading/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-30T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%EC%9E%98%EB%AA%A8%EB%A5%B4%EB%8A%94%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-30T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%97%86%EB%8A%94%ED%83%80%EC%9E%85%EC%9D%80/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-25T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%EC%84%A0%EC%96%B8/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-24T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%EB%AC%B8%EC%A0%9C%EC%A0%90/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-23T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/blog%EC%97%90GoogleSearching/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-21T01:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/fetch%EC%97%90%EB%8C%80%ED%95%B4%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-21T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BA%A0%ED%94%845%EA%B8%B0%EC%BD%94%ED%85%8C%ED%9B%84%EA%B8%B0/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-17T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/npmnpxyarn/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-05-03T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/Rest%EB%8A%94%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-04-30T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/ES%EB%AA%A8%EB%93%88%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-04-29T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/JS_localStorage/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-04-06T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/JS_RefreshStop/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-04-05T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/React_useReducer/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-30T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/ReactRouterV6/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-16T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/CRA%EC%97%86%EC%9D%B4React/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-11T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/github%EB%B8%94%EB%A1%9C%EA%B7%B8%ED%85%8C%EB%A7%88%EC%A0%81%EC%9A%A9/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-07T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/git%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1%EB%B0%A9%EB%B2%95/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-06T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%B2%AB%ED%8F%AC%EC%8A%A4%ED%8C%85/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-05T00:00:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://appletrick.github.io/posts/first-new-post/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-03-04T18:40:00+09:00&amp;lt;/lastmod&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;/urlset&amp;gt;sitemap.xml 을 생성후에 아까와 동일하게 root의 위치와 동일하게 위치해준다.robots.txt 생성하기User-agent: *Allow: /Sitemap: URL/sitemap.xmlURL 에 자신의 URL을 입력해주고 robots.txt root의 위치와 동일하게 위치해준다.Google Search에 sitemap 설정해주기새 사이트 맵에 sitemap.xml 을 추가해준다.현재 사진과 같이 가져올수 없음이라고 뜨는데.. 오래걸릴수도 있다고한다. 결과가 나오면 다시 포스팅 수정할것임참고https://ip99202.github.io/posts/깃허브-블로그-구글-검색-가능하게-하기/https://velog.io/@eona1301/Github-Blog-검색창-노출시키기" }, { "title": "fetch 에 대해 알아보자", "url": "/posts/fetch%EC%97%90%EB%8C%80%ED%95%B4%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/", "categories": "JS", "tags": "JS, fetch", "date": "2022-05-21 00:00:00 +0900", "snippet": "데이터 통신에는 Ajax, fetch, Axios 등 다양한 종류가 있다.그 중 ES6 내장 데이터 통신인 fetch 에 대해 알아보자fetch 란? fetch는 JS의 ES6부터 생긴 내장 라이브러리이다. 때문에 별도의 설치 없이 사용할 수 있고, 비동기 통신을 지원한다. fetch의 반환값은 promise 객체를 받는다. 원래 값을 받으려면 then 을 통해 resolve 객체를 받는다.fetch(URL , option).then((response) =&amp;gt; console.log(&quot;response:&quot;, response))).catch((error) =&amp;gt; console.log(&quot;error:&quot;, error));;위와 같은 코드를 쓰면 option에 따라 URL 에서 데이터를 통신한다.option의 종류는 다음과 같다. method: ‘POST’, // *GET, POST, PUT, DELETE 등 mode: ‘cors’, // no-cors, *cors, same-origin cache: ‘no-cache’, // *default, no-cache, reload, force-cache, only-if-cached credentials: ‘same-origin’, // include, *same-origin, omit headers: {‘Content-Type’: ‘application/json’,// ‘Content-Type’: ‘application/x-www-form-urlencoded’,}, redirect: ‘follow’, // manual, *follow, error referrerPolicy: ‘no-referrer’, // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url body: JSON.stringify(data), // body의 데이터 유형은 반드시 “Content-Type” 헤더와 일치해야 함option은 각각의 사용 설정에 맞게 사용하자.!" }, { "title": "우아한테크캠프 5기 테스트 후기...", "url": "/posts/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BA%A0%ED%94%845%EA%B8%B0%EC%BD%94%ED%85%8C%ED%9B%84%EA%B8%B0/", "categories": "후기", "tags": "코딩테스트", "date": "2022-05-17 00:00:00 +0900", "snippet": "우아한테크캠프 5기 시험작년부터 천천히 코딩테스트도 준비해오고 나름 노력도 열심히 해왔다. 그런 바쁜 삶을 살던 중, 오랜만에 우아한테크캠프 코딩테스트 공고가 올라오자마자, 여태까지 하던 프로젝트 중단하고, 일주일전부터 여태까지 공부했던 내용을 차근차근 훑으면서 부터 천천히 시험을 봤다.1차 전형총 4문제가 출시되었다. 1~4문제 전부다 충분히 풀어볼만했고, 4번을 아쉽게 마지막 해결을 못해서 많이 아쉬웟다. 나중에 집에서 천천히 머리식히니 풀 방법이 생각난거 빼고는 정말 괜찮게 봤다.결과는 행복하게도 1차 통과 되었다.2차 전형2차 전형은 작년 네이버 웹툰 테스트 이후 처음이다. 작년 네이버 웹툰 실기 때는 모듈에 대한 공부를 하지도 않고봐서 화를 크게 봤다. 때문에 이번 우테캠 1차 합격 이후부터 모듈로 화면 구현하는법을 쭉 연습했다.코딩을하면서 항상 구현은 자신있다고 생각했는데, 바닐라 자바스크립트로 module구현 부분은 자주 접한 부분이 아니여서 부족한 부분이 자주 보였다. 공부하면 할 수록 새로운 방법들을 알 수 있었고, 2차 시험에 대한 공부이기도 했지만 미래에 반드시 필요한 부분을 공부한 기회가 되었다 생각한다.시험 본 후기결론은 할 만큼은 했다고 생각한다. 시간안에 보여줄수있는 부분은 구현했고, 여태까지 너무 편하게 라이브러리만 사용하다보니 실제로 구현에 어색했던게 많았다. 시간만 더 있으면 확실히 구현했을것이다.2차결과는 나오지 않았지만, 좋은 결과일지는 모르겠다.새롭게 배워야되는 부분은 나중에 포스팅하면서 정리해봐야겟다..더 잘하고 싶다." }, { "title": "npm? npx? yarn? 에 대한 내용", "url": "/posts/npmnpxyarn/", "categories": "개념", "tags": "node, npm, npx, yarn", "date": "2022-05-03 00:00:00 +0900", "snippet": "😃 동기node 를 사용할때마다 라이브러리를 불러와서 사용하는데, 가끔 상황에 따라 npm, npx, yarn 등으로 각각 실행 과 설치가 다를때 있다. 해당 이유가 궁금하기도 하고 알아보면 좋을거 같아 작성해본다.NPM?npm 이란 Node Package Manager 의 약자로 node.js 의 패키지를 관리해주는 패키지 툴이다.많은 개발자들이 npm 사이트에 많은 모듈들을 올려놓아 다운 하여 편한게 사용할 수 있다.yarn?그럼 yarn은 어떤 존재일까? yarn 은 페이스북에서 만든 자바스크립트 패키지 매니저이다. npm과 같은 역할을 해준다. 같은 역할을 하지만 yarn 은 npm의 단점을 보완해서 나온 패키지 매니저이다.yarn이 npm보다 나은점 속도 : 흔히 패키지를 설치할때 yarn 은 병렬로 처리 npm 은 순차적를 하면서 설치할때 속도적 차이가 생긴다. 보안 : npm은 패키지들을 설치할때 자동으로 코드가 의존적으로 처리되게 만들었는데, 이 때문에 안전이 보장되지 않은 패키지가 설치될 경우 문제가 발생이 생길 수 있다. 안정성 : yarn은 yarn.lock 파일을 통해 버전 차이를 극복시켜준다. 물론 npm도 할수있지만, yarn은 기본세팅이기 때문yarn 이 그럼 무조건 npm 보다 좋은거 아닌가?“❌”yarn도 단점이 있다. yarn은 npm 보다 디스크 메모리를 더 잡아먹는것도 있을수도 있고, yarn.lock때문에 만약 기존 모듈이 최신으로 업데이트할 경우 하위호환을 지원 못할수도있다. 하지만 무엇보다 npm 이 yarn 보다 좋은점은 npm을 사용하고 있는 사람들과 현재까지 npm에 저장되어있는 다양한 package 들이다.때문에 yarn이 npm보다 무조건 좋다고는 말은 못한다. 결국 취향차이와 자기의 상황에 맞게 쓰면 될거 같다.NPX?위에 두개는 알겠다.npm, yarn은 는 자바스크립트 패키지 매니져이고 외부에서 패키지를 가지고 올 때 사용하는것인데 npx는 뭘까npx는 Node Package eXecute 노드 패키지의 실행을 도구이다. npm 5.2.0 버젼에서 추가되었다.npm run my-packagenpx my-package보다 간단하게 프로젝트 실행가능, 또한 npx 로는 설치를 안하고 실행도 가능하다." }, { "title": "Rest / RestAPI / RestFul 는 무엇일까?", "url": "/posts/Rest%EB%8A%94%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/", "categories": "개념", "tags": "rest, restapi, restful", "date": "2022-04-30 00:00:00 +0900", "snippet": "프로젝트를 진행하면서, 취업사이트에 구인구직을 하면서 항상 보는 단어가 RestFul API 이다. 이 RestFul API는 무엇일까?이를 위해서 우선 Rest가 무엇인지 알아보자Rest란?☝🏻 REST는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다.Rest의 약자는 “Representational State Transfer”이다.웹상에서 서로 정보를 주고 받을때, 자원을 이름으로 구분하여 주소를 통해 이에 대한 자원을 CRUD 한다Rest 의 구성 HTTP URI(Uniform Resource Identifier) HTTP Method CRUD OperationRest의 구성은 HTTP URI , HTTP Method, CRUD Operation 으로 구성 되어있다.말은 매우 어렵지만 해석은 간단하다.1. HTTP URI를 통한 자원을 명시즉 주소창에서 …./post/1 은 “게시글(post)의 1 번글” 과 같은 명시를 해준다.2. HTTP Method를 통한 행위 명시HTTP Method의 종류는 여러가지가 있다.- GET : 리소스 조회- POST : 주로 데이터 등록에 사용- PUT : 리소스를 대체, 해당 리소스가 없으면 생성- PATCH : 리소스를 일부만 변경- DELETE : 리소스 삭제그외 기타 메소드 HEAD, OPTIONS ,CONNECT ,TRACE등이 있다.위의 주요 5개의 메소드를 통해 위의 주소에 행위를 요청한다ex) GET …/post/1 “게시글 1번을 보여줘!”ex) DELETE …/post/3 “게시글 3번을 삭제해줘!”3. 자원에 대한 CRUD Operation 적용HTTP Method에 대한 요청에 대해 CRUD(Create , Read, Update, Delete) 등의 행위를 해준다.자원 보여주는 반환형태가 있을 수도 있고, 자원을 삭제, 수정의 명령이 적용된다.그래서 Rest란?결론은 Rest란 자원에 명칭을 주소화하여 어떤 명령인지를 인지하고 이를 통해 자원을 보기,생성,수정,삭제를 항는것이라고 결론 내릴 수 있다.그럼 Rest API 란 무엇일까?Rest API 란 더욱 간단하다 REST 기반으로 서비스 API를 구현한것으로, 서비스에서 Rest 라는 아키텍처에 원리를 지키는것을 의미한다.Rest 의 원리는 다음과 같다.- URI는 동사보다는 명사를, 대문자보다는 소문자를 사용- 마지막에 슬래시 (/)를 포함하지 않는다.- 언더바 대신 하이폰을 사용한다.- 파일확장자는 URI에 포함하지 않는다.- 행위를 포함하지 않는다.Okay 그럼 마지막으로 Restful 은 뭐야?더욱 간단하다. Rest API 를 지원하는 웹서비스를 Restful 이라고 할 수 있다.후기Rest에 대한 내용을 공부할 수 있다. 최근에 프로젝트 기능을 구현하면서, 궁금했던 내용을 글로 정리하니 마음이 편하다. 깊이 파면 더 많은 내용이 존재하지만, 지금은 이 정도로 충분하다 생각된다!" }, { "title": "ES 모듈 import/export 문법 사용", "url": "/posts/ES%EB%AA%A8%EB%93%88%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/", "categories": "Node", "tags": "node, module, react", "date": "2022-04-29 00:00:00 +0900", "snippet": "ES 모듈 import/export 문법 사용하기기존 리액트 프로젝트에서 사용해 오던 ES 모듈 import/export 문법은 Node.js에서는 지원 ❌Node.js v12부터 ES Module 기능이 정식으로 지원됩니다.package.json에서 코드 추가로 사용가능(...) &quot;scripts&quot;: { &quot;start&quot;: &quot;node src&quot;, &quot;start:dev&quot;: &quot;nodemon --watch src/ src/index.js&quot; }, &quot;type&quot;: &quot;module&quot;}❗️Parsing error: ‘import’ and ‘export’ may appear only with ‘sourceType: module’ (eslint 오류)node 에서 ES 모듈을 사용하려고 하엿는데 바꾸는 도중 해당 오류 발생.eslintrc.json 파일에 sourceType , module 추가&quot;parserOptions&quot;: { &quot;sourceType&quot;: &quot;module&quot;, },‼️ ES 모듈 사용시 주의 사항import * as postsCtrl from &quot;./posts.ctrl.js&quot;;import를 할때 정확한 무슨 파일인지 뒤에 확장자명까지 반드시 명시 해줄것추후 웹팩으로 해당 부분을 수정하여 사용할 수 있음‼️" }, { "title": "데이터 정보를 저장하는 LocalStorage", "url": "/posts/JS_localStorage/", "categories": "JS", "tags": "javscript", "date": "2022-04-06 00:00:00 +0900", "snippet": "LocalStorage는 웹에서 파일을 저장할 수 있는 기능, 작은 DB라고 생각하면 된다.localStorage.setItem()setItem의 경우 Key , Value 형식으로 값을 저장할 수 있다.localStorage.setItem(&quot;username&quot;, &quot;park&quot;);localStorage.getItem()getItem은 localStorage에 저장된 값을 불러 온다.const name = localStorage.getItem(&quot;username&quot;);localStorage.removeItem()removeItem은 localstorage 의 값을 삭제한다.localStorage.removeItem(&quot;username&quot;);" }, { "title": "JS로 새로고침 막기", "url": "/posts/JS_RefreshStop/", "categories": "JS", "tags": "javascript", "date": "2022-04-05 00:00:00 +0900", "snippet": "새로고침을 막는 preventDefaultHTML&amp;lt;form id=&quot;login-form&quot;&amp;gt; &amp;lt;input required maxlength=&quot;15&quot; type=&quot;text&quot; placeholder=&quot;what is your name? &quot; /&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;log in&quot; /&amp;gt;&amp;lt;/form&amp;gt;Javascriptconst loginForm = document.querySelector(&quot;#login-form&quot;);const loginInput = document.querySelector(&quot;#login-form input&quot;);const onLoginSubmit = (event) =&amp;gt; { event.preventDefault(); console.log(event);};loginForm.addEventListener(&quot;submit&quot;, onLoginSubmit);form 을 통해서 값을 전달 할 때 submit 이벤트가 실행되면 onLoginSubmit 함수가 실행된다.실행된 함수의 매개변수의 값은 기본적으로 방금 실행된 이벤트에 대한 정보를 담고 있다.그 중 preventDefault는 페이지의 새로고침을 막는다." }, { "title": "useReducer란?", "url": "/posts/React_useReducer/", "categories": "React", "tags": "react, usereducer", "date": "2022-03-30 00:00:00 +0900", "snippet": "state와 useReducer의 차이state의 경우const [state, setState] = useState(0);setState(state + 1);useReducer의 경우function reducer(oldState, action) { if (action == &quot;up&quot;) { return oldState + 1; }}[state, dispatch] = useReducer(reducer, 0);dispatch(&quot;up&quot;);State의 코드import React, { useState } from &quot;react&quot;;const App = () =&amp;gt; { const [count, setCount] = useState(0); const down = () =&amp;gt; { setCount(count - 1); }; const reset = () =&amp;gt; { setCount(0); }; const up = () =&amp;gt; { setCount(count + 1); }; return ( &amp;lt;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;-&quot; onClick={down} /&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;0&quot; onClick={reset} /&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;+&quot; onClick={up} /&amp;gt; &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt; &amp;lt;/&amp;gt; );};export default App;state의 값을 직접적으로 변경할 수 있다. 대부분은 state를 통해 값에대해 직접적으로 접근할 수 있다.어디에서 문제인가?만약에 count와 같은 변경되는 값이 한개가 아니라 여러개이면? 각각의 state의 값을 변경하게 할 것 인가?reducercount [값 , 처리하는 방식을 정해주는 함수명] = useReducer(처리 방법이 정해진 함수 , 초기값)state와 reducer의 차이는 useReducer를 사용한다.state를 직접 사용자가 변견하는것이 아니라 reducer가 직접적으로 해준다.import React, { useReducer } from &quot;react&quot;;const App = () =&amp;gt; { function countReducer(oldCount, action) { if (action == &quot;UP&quot;) { return oldCount + 1; } else if (action == &quot;RESET&quot;) { return 0; } else if (action == &quot;DOWN&quot;) { return oldCount - 1; } } const [count, countDispatch] = useReducer(countReducer, 0); const down = () =&amp;gt; { countDispatch(&quot;DOWN&quot;); }; const reset = () =&amp;gt; { countDispatch(&quot;RESEt&quot;); }; const up = () =&amp;gt; { countDispatch(&quot;UP&quot;); }; return ( &amp;lt;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;-&quot; onClick={down} /&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;0&quot; onClick={reset} /&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;+&quot; onClick={up} /&amp;gt; &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt; &amp;lt;/&amp;gt; );};export default App;만약 값을 직접적으로 설정하고 싶다면?import React, { useReducer, useState } from &quot;react&quot;;const App = () =&amp;gt; { const [number, setNumber] = useState(1); function countReducer(oldCount, action) { if (action.type == &quot;UP&quot;) { return oldCount + action.number; } else if (action.type == &quot;RESET&quot;) { return 0; } else if (action.type == &quot;DOWN&quot;) { return oldCount + action.number; } } const [count, countDispatch] = useReducer(countReducer, 0); const down = () =&amp;gt; { countDispatch({ type: &quot;DOWN&quot;, number: number }); }; const reset = () =&amp;gt; { countDispatch({ type: &quot;RESET&quot;, number: number }); }; const up = () =&amp;gt; { countDispatch({ type: &quot;UP&quot;, number: number }); }; const changeNumber = (event) =&amp;gt; { setNumber(Number(event.target.value)); }; return ( &amp;lt;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;-&quot; onClick={down} /&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;0&quot; onClick={reset} /&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;+&quot; onClick={up} /&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;input type=&quot;text&quot; value={number} onChange={changeNumber} /&amp;gt; &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt; &amp;lt;/&amp;gt; );};export default App;dispatch 쪽에 값을 객체 단위로 전달하여 함수에 직접적으로 값을 은닉하여 전달할 수 있다." }, { "title": "React-Router 사용하고 활용하기", "url": "/posts/ReactRouterV6/", "categories": "React", "tags": "react, routing", "date": "2022-03-16 00:00:00 +0900", "snippet": "라우팅이란?라우팅이란 유저가 요청한 URL 에 따라 원하는 페이지를 보여주는것을 의미한다.리액트에서 라우팅은 페이지별로 나눠져 있는 컴포넌트를 관리하기 위한 시스템이다.리액트에서 라우팅시스템을 구현하는 방법은 두가지가 있는데 리액트 라우터(React Router) : 리액트 라우터는 기존의 시스템에서 가장 많이 사용되는 시스템이다. Next.js : 리액트 프로젝트의 프레임워크로 다양한 기능을 제공하는데 그중 하나가 리액트 라우팅 시스템이다.React-Router 사용하기현재 이글에서는 기초적인 리액트 라우터만 써보기로 하자React-Router 설치npm i react-router-domindex.js 에서 라우팅 시스템을 적용프로젝트 전체에 리액트 라우터를 적용하기 위해서는 메인 루트가 되는 index.js에 react-router를 적용시켜준다.import React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;import App from &quot;./src/App&quot;;import { BrowserRouter } from &quot;react-router-dom&quot;;ReactDom.render( &amp;lt;BrowserRouter&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/BrowserRouter&amp;gt;, document.getElementById(&quot;root&quot;));라우팅시킬 페이지 생성Home.jsximport React from &quot;react&quot;;const Home = () =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;홈&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;가장 먼저 보여지는 홈 페이지 입니다.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; );};export default Home;About.jsximport React from &quot;react&quot;;const About = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;h1&amp;gt;about&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;about 페이지 입니다.&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; );};export default About;메인 실행 페이지App.jsximport React from &quot;react&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import Home from &quot;./skillFolder/Routing/pages/home&quot;;import About from &quot;./skillFolder/Routing/pages/about&quot;;const App = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/about&quot; element={&amp;lt;About /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; &amp;lt;/&amp;gt; );};export default App; 의 규칙&amp;lt;Route path=&quot;주소규칙&quot; element={보여 줄 컴포넌트 JSX} /&amp;gt;위 의 규칙은 꼭 지켜주자결과페이지정상적으로 햇을 경우 아래와 같은 이미지의 결과 페이지가 나오게 된다. 를 이용하여 다른 컴포넌트로 가는법Link를 이용하면 다른 컴포넌트로 이동할 수 있는 수단이 생긴다. 태그는 브라우저의 새로운 페이지를 불러오기 때문에 리액트에서는 사용 하면안된다. 태그는 역할을 같지만 브라우저의 새로운 페이지는 부르지 않고 History API 에 브라우저 경로 변경만 해준다. &amp;lt;Link to=&quot;경로&quot;&amp;gt;링크 이름&amp;lt;/Link&amp;gt;home.jsximport React from &quot;react&quot;;import { Link } from &quot;react-router-dom&quot;;const Home = () =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;홈&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;가장 먼저 보여지는 홈 페이지 입니다.&amp;lt;/p&amp;gt; &amp;lt;Link to=&quot;./about&quot;&amp;gt;소개&amp;lt;/Link&amp;gt; &amp;lt;/div&amp;gt; );};export default Home;URL 파라미터와 URL 쿼리스트링을 이용한 페이지 정보URL 파라미터 : 주소의 경로에 유동적인 값을 넣는 형태, 주로 특정 데이터를 조회할 때 사용쿼리 스트링은 주소의 뒷부분에 ? 문자열 이후에 key=value 로 값을 정의하며 &amp;amp; 로 구분을 하는 형태 주로 정렬 방식의 데이터 조회에 필요한 옵션을 전달 할때 사용 URL파라미터 : /profile/Appletrick URL쿼리스트링 : /main?**page=1&amp;amp;keyword=nameURL 파라미터 이용해보기App.jsxconst App = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/about&quot; element={&amp;lt;About /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/profile/:username&quot; element={&amp;lt;Profile /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; &amp;lt;/&amp;gt; );};라우팅을 해줄때 profile로 가면 :username을 매개변수로 파라미터로 받아준다.Home.jsxconst Home = () =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;홈&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;가장 먼저 보여지는 홈 페이지 입니다.&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/about&quot;&amp;gt;소개&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/profile/appletrick&quot;&amp;gt;Appletrick&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/profile/steve&quot;&amp;gt;스티브잡스&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/profile/who&quot;&amp;gt;누구?&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; );};profile에서 매개변수로 appletrick, steve, who 3개로 나뉘게 된다.**profile.jsx** 를 만들어주자import React from &quot;react&quot;;import { useParams } from &quot;react-router-dom&quot;;const data = { appletrick: { name: &quot;Appletrick&quot;, about: &quot;멋진 개발자&quot;, }, steve: { name: &quot;스티브잡스&quot;, about: &quot;애플의 창시자&quot;, },};const Profile = () =&amp;gt; { const params = useParams(); const profile = data[params.username]; return ( &amp;lt;&amp;gt; &amp;lt;h1&amp;gt;사용자 프로필&amp;lt;/h1&amp;gt; {profile ? ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;{profile.name}&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;{profile.about}&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; ) : ( &amp;lt;p&amp;gt;존재하지 않는 사람 입니다.&amp;lt;/p&amp;gt; )} &amp;lt;/&amp;gt; );};export default Profile; 임시적인 data 오브젝트를 생성해준다. useParams()를 통해 URL 파라미터값을 가지고온다. profile 변수에 data 파라미터 값과 일치한 내용을 가지고와서 화면에 띄어준다.☝🏻 URL 파라미터는 `/profiles/:usernam`과 같이 경로에 `:`를 사용하여 설정만약 URL 파라미터가 여러개인 경우엔 `/profiles/:username/:field`와 같은 형태로 설정쿼리 스트링 사용해보기쿼리스트링을 **about.jsx** 에서 띄어보기useLocation을 통해 쿼리스트링의 경로를 나타내준다.import React from &quot;react&quot;;import { useLocation } from &quot;react-router-dom&quot;;const About = () =&amp;gt; { const location = useLocation(); console.log(location); return ( &amp;lt;&amp;gt; &amp;lt;h1&amp;gt;about&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;리액트 라우터사용하는 페이지&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;현재의 쿼리 스트링 {location.search}&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; );};export default About;주소값을 http://localhost:3000/about?detail=true&amp;amp;mode=1 해줄경우화면에 useLocation() 훅을 이용하여 쿼리스트링을 화면에 띄울수 있다.location 객체 안의 값 pathname : 현재주소 hash : 주소의 # 문자열 뒤의 값 state: 페이지로 이동할때 임의로 넣을 수 있는 상태 값 key: location 객체의 고유 값, 초기에는 default 이며 페이지가 변경될때마다 고유의 값이 생성됨 search: 맨 앞의 ? 문자 포함한 쿼리스트링 값현재의 쿼리 스트링은 ?detail=true&amp;amp;mode=1 값인데 이 값을 key 와 value로 분류하는 작업은 npm에 qs 또는 querystring을 통해 가능하다.(원래는 npm의 qs, querystring을 통해 해야 했지만 v6버전 부터 리액트로 할것)리액트 라우터에서는 v6 버젼부터 useSearchParam을 통해 쉽게 쿼리스트링을 다룰 수 있다.import React from &quot;react&quot;;import { useSearchParams } from &quot;react-router-dom&quot;;const About = () =&amp;gt; { const [searchParams, setSearchParams] = useSearchParams(); const detail = searchParams.get(&quot;detail&quot;); const mode = searchParams.get(&quot;mode&quot;); console.log(typeof mode, typeof detail); const onToggleDetail = () =&amp;gt; { setSearchParams({ mode, detail: detail === true ? false : true }); }; const onIncreaseMode = () =&amp;gt; { const nextMode = mode == &quot;null&quot; ? 1 : parseInt(mode) + 1; setSearchParams({ mode: nextMode, detail }); }; return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;소개&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;리액트 라우터를 사용해 보는 프로젝트입니다.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;detail: {detail}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;mode: {mode}&amp;lt;/p&amp;gt; &amp;lt;button onClick={onToggleDetail}&amp;gt;Toggle detail&amp;lt;/button&amp;gt; &amp;lt;button onClick={onIncreaseMode}&amp;gt;mode + 1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );};export default About;핵심 useSearchParams() 는 배열값으로 값을 반환한다. 첫번째 값은 쿼리파라미터의 값을 조회하는것 (searchParams이부분 ) 두번째 값은 쿼리파라미터의 값을 수정하거나 업데이트 (setSearchParams 부분) 을가지고 온다.. 조회하여 값을 가지고 올때는 모두 string 문자열 값을 취하기 때문에 값을 더 하거나 뺄때는 parseInt() 를 통해 값을 조정한다.중첩된 라우팅중첩된 라우팅을 사용하는 방법article.jsximport React from &quot;react&quot;;import { Link, Outlet } from &quot;react-router-dom&quot;;const Article = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Outlet /&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/articles/1&quot;&amp;gt;게시글 1&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/articles/2&quot;&amp;gt;게시글 2&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/articles/3&quot;&amp;gt;게시글 3&amp;lt;/Link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/&amp;gt; );};export default Article;article.jsximport React from &quot;react&quot;;import { useParams } from &quot;react-router-dom&quot;;const Article = () =&amp;gt; { const { id } = useParams(); return ( &amp;lt;&amp;gt; &amp;lt;h2&amp;gt;게시글 {id}&amp;lt;/h2&amp;gt; &amp;lt;/&amp;gt; );};export default Article;home.jsx&amp;lt;li&amp;gt; &amp;lt;Link to=&quot;/articles&quot;&amp;gt;게시글 목록&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;app.jsx&amp;lt;&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/about&quot; element={&amp;lt;About /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/profile/:username&quot; element={&amp;lt;Profile /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/articles&quot; element={&amp;lt;Articles /&amp;gt;}&amp;gt; &amp;lt;Route path=&quot;:id&quot; element={&amp;lt;Article /&amp;gt;} /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;/Routes&amp;gt;&amp;lt;/&amp;gt;OutLet 컴포넌트를 사용할것OutLet 컴포넌트는 Route에서 자식요소로 들어가는 부분을 보여줄수 있다좀더 나은 중첩방식 OutletOutLet 은 공통적인 부분을 보여줄때 효율적으로 사용할수 있다.기존에 Header는 헤더부분을 따로 만들고 컴포넌트화 시키고 따로 페이지를 보여주는 방법도 있지만 Outlet은 조금더 효율적으로 화면을 보여줄 수 있다.Layout.jsximport React from &quot;react&quot;;import { Outlet , useNavigate} from &quot;react-router-dom&quot;;const Layout = () =&amp;gt; { const navigate = useNavigate(); const goBack = () =&amp;gt; { navigate(-1); } const goArticle = () =&amp;gt; { navigate(&#39;/articles&#39; , {replace : true}); }/ const goAbout = () =&amp;gt; { navigate(&#39;/about&#39;); } return( &amp;lt;&amp;gt; &amp;lt;header style={ {background : &quot;royalblue&quot; , padding : 16 , fontSize : 24}}&amp;gt; &amp;lt;button onClick={goBack}&amp;gt;뒤로가기&amp;lt;/button&amp;gt; &amp;lt;button onClick={goArticle}&amp;gt;게시글목록&amp;lt;/button&amp;gt; &amp;lt;button onClick={goAbout}&amp;gt;소개로&amp;lt;/button&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;main&amp;gt; &amp;lt;Outlet/&amp;gt; &amp;lt;/main&amp;gt; &amp;lt;/&amp;gt; )}export default Layout; useNavigate 는 Link component를 사용하지 않고 페이지를 이동시키는 훅이다.App.jsximport { Route, Routes } from &quot;react-router-dom&quot;;import Layout from &quot;./Layout&quot;;import About from &quot;./pages/About&quot;;import Article from &quot;./pages/Article&quot;;import Articles from &quot;./pages/Articles&quot;;import Home from &quot;./pages/Home&quot;;import Profile from &quot;./pages/Profile&quot;;const App = () =&amp;gt; { return ( &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Layout /&amp;gt;}&amp;gt; &amp;lt;Route index element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/about&quot; element={&amp;lt;About /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/profiles/:username&quot; element={&amp;lt;Profile /&amp;gt;} /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;Route path=&quot;/articles&quot; element={&amp;lt;Articles /&amp;gt;}&amp;gt; &amp;lt;Route path=&quot;:id&quot; element={&amp;lt;Article /&amp;gt;} /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;/Routes&amp;gt; );};export default App;layout을 기본 페이지로 하여 하위 요소를 Outlet을 통해 나타낼수 있다.Layout의Route의 path는 “/” 루트로 된고 Home component의 index props 는 path = “/” 와 같은 의미 이다.const navigate = useNavigate();navigate(); navigate (?)파라미터 값이 숫자면 해당 숫자만큼 앞으로 가거나 뒤로감, 주소를 입력할경우 해당 주소로 가게됨,replace라는 옵션은 해당 페이지 기록을 남기않게됨NavLink를 사용해보자현재 라우트의 경로와 일치하는 경우 특정 스타일 또는 CSS 클래스를 적용하는 컴포넌트artcles.jsximport React from &quot;react&quot;;import { NavLink, Outlet } from &quot;react-router-dom&quot;;const Article = () =&amp;gt; { const activeStyle = { color: &quot;green&quot;, fontsize: 21, }; return ( &amp;lt;&amp;gt; &amp;lt;Outlet /&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;NavLink to=&quot;/articles/1&quot; style={({ isActive }) =&amp;gt; (isActive ? activeStyle : undefined)} &amp;gt; 게시글 1 &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;NavLink to=&quot;/articles/2&quot; style={({ isActive }) =&amp;gt; (isActive ? activeStyle : undefined)} &amp;gt; 게시글 2 &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;NavLink to=&quot;/articles/3&quot; style={({ isActive }) =&amp;gt; (isActive ? activeStyle : undefined)} &amp;gt; 게시글 3 &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/&amp;gt; );};export default Article;중복된 코드를 최소화하고 같이 묶어서 쓰는법import React from &quot;react&quot;;import { NavLink, Outlet } from &quot;react-router-dom&quot;;const Articles = () =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;Outlet /&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;ArticleItem id={1} /&amp;gt; &amp;lt;ArticleItem id={2} /&amp;gt; &amp;lt;ArticleItem id={3} /&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; );};const ArticleItem = ({ id }) =&amp;gt; { const activeStyle = { color: &quot;green&quot;, fontSize: 21, }; return ( &amp;lt;li&amp;gt; &amp;lt;NavLink to={`/articles/${id}`} style={({ isActive }) =&amp;gt; (isActive ? activeStyle : undefined)} &amp;gt; 게시글 {id} &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; );};export default Articles;NotFound Page만들기NotFound페이지는 경로가 지정되지 않은 페이지로 주소가 갈 때 이를 해결해주는 페이지 이다.NotFound.jsximport React from &#39;react&#39;;const NotFound = () =&amp;gt; { return( &amp;lt;div style={{ display: &#39;flex&#39;, alignItems: &#39;center&#39;, justifyContent: &#39;center&#39;, fontSize: 64, position: &#39;absolute&#39;, width: &#39;100%&#39;, height: &#39;100%&#39;, }} &amp;gt; 404 &amp;lt;/div&amp;gt; )}export default NotFound;App.jsx 에 NotFound를 축가&amp;lt;Route path=&quot;*&quot; element={&amp;lt;NotFound /&amp;gt;} /&amp;gt;Navigate 컴포넌트를 이용한 loginpageMyPage.jsximport React from &quot;react&quot;;import { Navigate } from &quot;react-router-dom&quot;;const MyPage = () =&amp;gt; { const isLogIn = false; if (!isLogIn) { return &amp;lt;Navigate to=&quot;/login&quot; replace={true} /&amp;gt;; } return &amp;lt;&amp;gt;My Page&amp;lt;/&amp;gt;;};export default MyPage;Navigate 컴포넌트를 통해 로그인이 되지 않으면 login page로 가게 설정Login.jsximport React from &quot;react&quot;;const Login = () =&amp;gt; { return &amp;lt;&amp;gt;로그인 페이지&amp;lt;/&amp;gt;;};export default Login;App.jsx&amp;lt;Route path=&quot;/login&quot; element={&amp;lt;Login/&amp;gt;}/&amp;gt;&amp;lt;Route path=&quot;/mypage&quot; element={&amp;lt;MyPage/&amp;gt;}/&amp;gt;두개 항목 추가해줄것내용 https://velog.io/@velopert/react-router-v6-tutorial#64-navigate-컴포넌트" }, { "title": "CRA (Create-React-App) 없이 리액트 만들어보기", "url": "/posts/CRA%EC%97%86%EC%9D%B4React/", "categories": "React", "tags": "react", "date": "2022-03-11 00:00:00 +0900", "snippet": "package.json 설치cra 없이 react를 시작하기 위해 프로젝트에 node를 설치해줘야된다.터미널에 아래와 같은 명령어 입력npm init -y -y는 npm 설치를 default 값으로 해주는경우 써준다. 디테일한 세부 설정을 하려면 npm init 만 써주도록 하자React 설치react를 사용하기위해서 npm에서 react 와 react-dom 설치npm install react react-dombabel 설치원활한 react 사용을 위한 babel 설치npm install -D @babel/core @babel/preset-env @babel/preset-react @babel/core : 바벨의 코어 @babel/preset-env : ES6코드를 ES5로 트랜스파일링 @babel/preset-react : 리액트 JSX를 트랜스파일링 바벨은 개발때만 사용하므로 명령어에 -D를 붙여줌으로 써 package.json에서 dependencies에 담기지 않고 devDependencies 담기기 위해 사용babel 설정파일 .babelrc 파일을 생성 및 내용 입력바벨의 설정값을 사용하기 위해 .babelrc 파일 생성 (바벨의 설정파일){ &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;: []}webpack 설치npm install -D webpack webpack-cli webpack-dev-server webpack : 웹팩의 코어를 의미 webpack-cli : 웹팩을 커맨드라인에서 사용가능 하게함 webpack-dev-server : 웹팩을 메모리 상에 빌드하여 개발 서버를 구동webpack의 번들링에 필요한 loader 관련 설치npm install -D babel-loader style-loader css-loader file-loader html-loader babel-loader : JSX 및 ES6+ 문법을 트랜스파일링 style-loader : 변환된 CSS 파일을 &amp;lt;style&amp;gt; 태그로 감싸서 삽입 css-loader : CSS 파일을 자바스크립트가 이해할 수 있도록 변환 file-loader : 이미지 및 폰트 등의 파일 로딩 html-loader : html을 읽을 수 있음webpack에 필요한 플러그인 설치npm install -D html-webpack-plugin clean-webpack-plugin html-webpack-plugin : HTML 파일에 번들링된 자바스크립트 파일을 삽입해주고 번들링된 결과가 저장되는 폴더에 옮김. clean-webpack-plugin : 번들링을 할 때마다 이전 번들링 결과를 제거. mini-css-extract-plugin : css 파일로 변환해주는 플러그인.☝🏻 &quot;style-loader&quot;와 MiniCssExtractPlugin.loader를 함께 사용하면 안됩니다webpack 설정파일 webpack.config.js 파일 생성 및 내용입력const path = require(&quot;path&quot;);module.exports = { mode: &quot;development&quot;, entry: &quot;./index.js&quot;, resolve: { extensions: [&quot;.js&quot;, &quot;.jsx&quot;], }, output: { //path: path.resolve(__dirname, &#39;./dist&#39;), filename: &quot;bundle.[hash].js&quot;, },}; require(’path’) : 노드에서 지원해주는 경로 모듈을 불러온다. mode : 웹펙의 현재 모드를 설정 development / production / none 의 3가지 모드가 있다. entry : 어플리케이션이 어디에서 실행하는 지를 설정한다. resolve : 웹펙에서 파일을 처리할때 확장자를 생략해도 인식하게 만들수 있게 해줌 output.path : 결과물을 출력할때 나오게하는 곳을 직접 지정할 수 있음 output.filename : 파일이름을 설정 할 수 있음 [hash]는 컴파일할때 사용한 hash를 사용하게 됨devtool: &#39;eval-cheap-source-map&#39;, devtool : source-map을 설정하는 부분으로 에러가 발생했을 때 번들링된 파일에서 어느 부분에 에러가 났는지를 쉽게 확인할 수 있게 해주는 도구const port = process.env.PORT || 3000;----devServer: { host: &#39;localhost&#39;, port: port, hot : true, open: true, }, process.env.PORT   3000 : 포트번호 설정 devServer : webpack-dev-server의 옵션 설정 overlay : 에러 발생 시 브라우저에 내용을 띄울지 설정 hot : 모듈의 변화만 자동으로 로드하는 HMR(Hot Module Replacement) 기능 활성화 설정module: { rules: [ { test: /\\.(js|jsx)$/, exclude: &#39;/node_modules/&#39;, loader: &#39;babel-loader&#39;, }, { test: /\\.css$/, // use: [&#39;style-loader&#39;, &#39;css-loader&#39;], use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;], }, { test: /\\.(jpeg|jpg)$/, loader: &#39;file-loader&#39;, options: { name: &#39;[name].[ext]&#39;, }, }, ], },모듈부분 추가 modules, rules : 모듈에 적용할 로더들과 그 옵션들을 설정 test : 어떤 파일에 적용할지 확장자 작성 exclude : 로더에서 제외할 파일 설정 loader : 적용할 로더가 1개라면 loader로 설정 use : 적용할 로더가 2개 이상이면 use 배열로 설정플러그인 추가 코드// 설치된 플러그인들을 불러온다.const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);//const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);const {CleanWebpackPlugin} = require(&#39;clean-webpack-plugin&#39;);-----plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: &#39;./public/index.html&#39;, }), // new MiniCssExtractPlugin({ filename: &#39;app.css&#39; }), // &quot;style-loader&quot;와 MiniCssExtractPlugin.loader를 함께 사용하면 안됩니다 ],모드코드const path = require(&quot;path&quot;);// 설치된 플러그인들을 불러온다.const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);//const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);// 기본 포트 설정const port = process.env.PORT || 3000;module.exports = { mode: &quot;development&quot;, entry: &quot;./index.js&quot;, resolve: { extensions: [&quot;.js&quot;, &quot;.jsx&quot;], }, output: { path: path.resolve(__dirname, &quot;./dist&quot;), filename: &quot;bundle.[hash].js&quot;, }, devtool: &quot;eval-cheap-source-map&quot;, devServer: { host: &quot;localhost&quot;, port: port, hot: true, open: true, }, module: { rules: [ { test: /\\.(js|jsx)$/, exclude: &quot;/node_modules/&quot;, loader: &quot;babel-loader&quot;, }, { test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], // use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;], }, { test: /\\.(jpeg|jpg|png)$/, loader: &quot;file-loader&quot;, options: { name: &quot;[name].[ext]&quot;, }, }, ], }, // 추가된 플러그인을 설정해주는곳 plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: &quot;./public/index.html&quot;, }), // new MiniCssExtractPlugin({ filename: &#39;app.css&#39; }), // &quot;style-loader&quot;와 MiniCssExtractPlugin.loader를 함께 사용하면 안됩니다 ],};package.json script 작성&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --progress&quot;, &quot;build&quot;: &quot;webpack&quot; }src에 파일 생성 App.jsximport React from &quot;react&quot;;const App = () =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt; &amp;lt;/&amp;gt; );};export default App;root에 index.js 파일 생성import React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;import App from &quot;./src/App&quot;;ReactDom.render(&amp;lt;App /&amp;gt;, document.getElementById(&quot;root&quot;));실행npm run dev" }, { "title": "github 블로그 테마적용", "url": "/posts/github%EB%B8%94%EB%A1%9C%EA%B7%B8%ED%85%8C%EB%A7%88%EC%A0%81%EC%9A%A9/", "categories": "Blogging", "tags": "블로그, 테마적용", "date": "2022-03-07 00:00:00 +0900", "snippet": "깃헙 블로그는 쉽게 jekyll로 사용하기로 결정1. 블로그 테마 결정하기 jamstackthemes.dev jekyllthemes.org jekyllthemes.io jekyll-themes.com테마 사이트 가서 테마 설정하기현재 내 블로그는 아래로 결정Chirpy2. 테마 파일 받아서 내 repository와 연결된 곳에 덮어쓰기.github 링크로 들어가서 아래 Download ZIP 해주기내 폴더에 풀어주기3. 실행 테스트 하기실행을 하기위해서 우선 {username}.github.io 에 들어가서 명령어 실행시킬것 실행기 설치bundle install jekyll 실행bundle exec jekyll serve server address 주소에서 정상적으로 동작하는지 확인해볼것 정상적으로 동작망할 오류..jykell 로 실행했을때는 정상적으로 페이지가 동작했는데github 블로그에서는 정상적으로 동작이 안할 때가 잇는데 내가 찾은 jkyell theme 가 그 중 하나였다.정상적으로 올리는 방법 _config.yml 파일 수정하고 tools/init.sh 명령어 실행 (매우 중요) git push github 에 들어가서 settings - pages 에서 설정을 아래와 같이 바꿔주자주의 사항 혹시라도 repo 에 Gemfile.lock 파일이 존재하는지 확인해보자 (Gemfile 아니다 Gemfile.lock 파일이다), 존재할경우 .gitignore 에 추가하여 제거하자 .nojkyell 파일이 존재하는지 확인하자 GitHub Pages는 Jekyll로 서버를 돌린다.그리고 Jekyll을 사용하지 않는 사이트는 Jekyll 서버가 돌아가지 않게 할 수도 있다. 테마에 따라 .nojekyll 파일이 필요할 수 도 있으니 이건 테마 확인해볼것 안될경우 파일 삭제하는 순서 압축 풀고 이름 바꾸고 디렉토리 들어간다. .travis.tml, _posts, docs 파일 및 디렉토리를 지운다. .github/workflows/pages-deploy.yml.hook 파일을 제외한 나머지 .github 내부 파일 및 디렉토리를 모두 지운다. 위 파일명에서 .hook 제거. bundle 입력 git 설정 후 git push " }, { "title": "github 블로그 생성 방법 1단계", "url": "/posts/git%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1%EB%B0%A9%EB%B2%95/", "categories": "Blogging", "tags": "블로그, github", "date": "2022-03-06 00:00:00 +0900", "snippet": "github 블로그 생성하는 법1. github 에서 repository 생성{username}.github.io 로 repository 생성2. index.html 과 README.md 생성 README.md 는 repository 생성할 때 체크해서 생성하면 편하다. index.html 에는 일단 hello world 만 내용 넣어주자.3. {username}.github.io 들어가서 확인하기위와 같은 내용이 나오면 성공" }, { "title": "블로스 jekyll에서 포스팅 쓰는 법 분석하기", "url": "/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%B2%AB%ED%8F%AC%EC%8A%A4%ED%8C%85/", "categories": "Blogging", "tags": "블로그, 글쓰기", "date": "2022-03-05 00:00:00 +0900", "snippet": "각 항목 분석하기 layout : 어떤 html 파일을 적용시킬것인지 확인할 수 있다. _layouts 디렉터리 밑에 있는 post.html 을 사용하여 글을 포스팅 title : 제목 쓰여지는 부분 date : 날짜 기록하는 방법 파일 이름을 YYYY-MM-DD-POST_TITLE.md 로 하면 자동으로 글의 시간을 파싱한다. 만약 같은 날 2개 이상의 포스트를 올리는 경우에는 시간을 고정시켜 포스팅 순서를 정해줄 수 있다. 파일명 작성할때 - 로 제대로 구별해주기! categories : 포스팅된 내용의 카테고리르 설정한다.배열[] 안에 2개 이상의 카테고리를 ,로 구분지어 넣으면 2개 이상의 카테고리가 적용.단, 이 경우 포스트의 주소가 ~/category1/category2/YYYY/MM/DD/POST_TITLE 처럼 url 주소가 생긴다. tags : 글 내용을 태그배열 [] 안에 ,로 구분지어 여러개의 tag 를 설정할 수 있다. description : 메인 화면에서 보여 질 미리보기 텍스트 comments사용하기 위해선 링크 에서 disqus 를 추가해 _config.yml 에 disqus: DISQUS_NAME을 추가한다. " }, { "title": "블로그 첫 포스트", "url": "/posts/first-new-post/", "categories": "Blogging", "tags": "writing", "date": "2022-03-04 18:40:00 +0900", "snippet": "블로그 처음으로 시작하기블로그 처음으로 시작 글 테스트기본적인 양식title: 블로그 첫 포스트author: name: 이름 link: 링크date: 2022-03-04 18:40:00 +0900categories: [Blogging, Tutorial]tags: [writing]" } ]
